<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>投资返利计算器</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .container { max-width: 600px; margin: auto; }
    label { display: block; margin: 10px 0 5px; }
    input { padding: 5px; width: 100%; }
    button { padding: 10px 20px; margin: 10px 0; }
    #result { margin-top: 20px; }
    #exchange-rate { position: fixed; top: 10px; right: 10px; background: #f0f0f0; padding: 10px; border-radius: 5px; }
  </style>
</head>
<body>
  <div id="exchange-rate">USDT/CNY: 7.175</div>
  <div class="container">
    <h2>投资返利计算器</h2>
    <label for="investment">投资金额（美元，最小100）:</label>
    <input type="number" id="investment" value="100" step="1" min="100">
    <label for="targetRebate">目标每日返利金额（美元）:</label>
    <input type="number" id="targetRebate" value="0.6" step="0.01" min="0.01">
    <button onclick="calculate()">计算</button>
    <div id="result"></div>
  </div>

  <script>
    // 模拟实时汇率，实际需替换为API调用
    const usdtCnyRate = 7.175; // 参考Wise，2025-07-30
    document.getElementById('exchange-rate').innerText = `USDT/CNY: ${usdtCnyRate.toFixed(4)}`;
    /*
    fetch('https://api.coingecko.com/api/v3/simple/price?ids=tether&vs_currencies=cny')
      .then(response => response.json())
      .then(data => {
        document.getElementById('exchange-rate').innerText = `USDT/CNY: ${data.tether.cny.toFixed(4)}`;
      })
      .catch(error => console.error('获取汇率失败:', error));
    */

    function calculate() {
      const investment = parseFloat(document.getElementById('investment').value);
      const targetRebate = parseFloat(document.getElementById('targetRebate').value);
      const leverage = 11;
      const dailyRate = 0.0005;
      const leverageFactor = 0.9995;
      const reinvestThreshold = 100;

      // 输入验证
      if (investment < 100) {
        document.getElementById('result').innerHTML = '<p style="color: red;">投资金额必须至少100美元！</p>';
        return;
      }
      if (targetRebate <= 0) {
        document.getElementById('result').innerHTML = '<p style="color: red;">目标每日返利必须为正数！</p>';
        return;
      }

      // 计算初始本金
      const initialCapital = investment * leverage;

      // 计算回本天数
      const breakEvenDay = Math.ceil(Math.log(1 - investment / initialCapital) / Math.log(leverageFactor));
      const breakEvenRebate = initialCapital * (1 - Math.pow(leverageFactor, breakEvenDay));

      // 计算复投时间
      let reinvestDays = [];
      let currentDay = 0;
      let capital = initialCapital;
      let cumulativeRebate = 0;
      let k = 0;
      const maxReinvest = 100; // 防止无限循环

      while (targetRebate > capital * dailyRate && k < maxReinvest) {
        const daysToNext = Math.ceil(Math.log(1 - reinvestThreshold / capital) / Math.log(leverageFactor));
        currentDay += daysToNext;
        reinvestDays.push(currentDay);
        capital = capital * Math.pow(leverageFactor, daysToNext) + reinvestThreshold * leverage;
        cumulativeRebate = 0; // 重置累计返利（复投后重新计算）
        k++;
      }

      // 计算首次每日返利达到目标金额
      let targetDay = 0;
      for (let i = 0; i <= reinvestDays.length; i++) {
        const prevDay = i === 0 ? 0 : reinvestDays[i - 1];
        const currentCapital = i === 0 ? initialCapital : (initialCapital * Math.pow(leverageFactor, reinvestDays[i - 1]) + 1100 * i);
        if (targetRebate <= currentCapital * dailyRate) {
          let n = prevDay + 1;
          while (true) {
            const dailyRebate = currentCapital * Math.pow(leverageFactor, n - prevDay - 1) * dailyRate;
            if (dailyRebate >= targetRebate) {
              targetDay = n;
              break;
            }
            n++;
            if (i < reinvestDays.length && n > reinvestDays[i]) break;
            if (n > prevDay + 10000) break;
          }
          if (targetDay > 0) {
            // 确保显示所有复投直到目标达成
            if (i === reinvestDays.length && targetRebate <= capital * dailyRate) {
              const daysToNext = Math.ceil(Math.log(1 - reinvestThreshold / capital) / Math.log(leverageFactor));
              currentDay += daysToNext;
              reinvestDays.push(currentDay);
            }
            break;
          }
        }
      }

      if (targetDay === 0) {
        // 额外复投直到达成目标
        let extraDay = reinvestDays.length > 0 ? reinvestDays[reinvestDays.length - 1] : 0;
        let extraCapital = capital;
        let extraK = k;
        while (targetRebate > extraCapital * dailyRate && extraK < maxReinvest) {
          const daysToNext = Math.ceil(Math.log(1 - reinvestThreshold / extraCapital) / Math.log(leverageFactor));
          extraDay += daysToNext;
          reinvestDays.push(extraDay);
          extraCapital = extraCapital * Math.pow(leverageFactor, daysToNext) + reinvestThreshold * leverage;
          extraK++;
        }
        let n = extraDay + 1;
        while (true) {
          const dailyRebate = extraCapital * Math.pow(leverageFactor, n - extraDay - 1) * dailyRate;
          if (dailyRebate >= targetRebate) {
            targetDay = n;
            break;
          }
          n++;
          if (n > extraDay + 10000) break;
        }
      }

      if (targetDay === 0) {
        document.getElementById('result').innerHTML = `<p style="color: red;">首次每日返利达到 ${targetRebate} 美元无法精确计算！</p>`;
        return;
      }

      // 输出结果
      const result = `
        <h3>计算结果（投资金额：${investment} 美元，约 ${investment * usdtCnyRate.toFixed(2)} 人民币）</h3>
        <p>累计返利回本（${investment} 美元）：第 <strong>${breakEvenDay}</strong> 天（约 ${Math.round(breakEvenDay / 365 * 10) / 10} 年），累计返利约 <strong>${breakEvenRebate.toFixed(2)}</strong> 美元</p>
        <p>复投次数：${reinvestDays.length} 次，复投时间（天）：${reinvestDays.join(', ')}</p>
        <p>首次每日返利达到 ${targetRebate} 美元：第 <strong>${targetDay}</strong> 天（约 ${Math.round(targetDay / 365 * 10) / 10} 年）</p>
        <p><strong>注意</strong>：每日返利随时间递减，首次达到表示某天返利首次大于或等于目标值。平台无复投次数限制，显示所有复投时间直到目标返利达成。</p>
      `;
      document.getElementById('result').innerHTML = result;
    }
  </script>
</body>
</html>